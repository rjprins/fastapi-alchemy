{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI-Ding","text":""},{"location":"#a-rest-framework-for-fastapi","title":"A REST Framework for FastAPI","text":""},{"location":"#installation","title":"Installation","text":"<p><pre><code>$ pip install fastapi-alchemy\n</code></pre> FastAPI-Alchemy (<code>fa</code>) is built on top of FastAPI and SQLAlchemy. It aims to be batteries-included, providing tools and utilities commonly needed in FastAPI projects that get deployed into production.</p>"},{"location":"#example-usage","title":"Example Usage","text":"<p><code>fa</code> gives you REST endpoints for a SQLAlchemy model in a completely customizable and extendable way. Here's the smallest possible example:</p> <pre><code>import fastapi_alchmey as fa\nfrom fastapi import FastAPI\nfrom sqlalchemy.orm import Mapped\n\n\nfa.settings.async_database_url = \"sqlite+aiosqlite:///blog.db\"\n\n\napp = FastAPI()\n\n\nclass Blog(fa.IDBase):\n    title: Mapped[str]\n\n\nclass BlogSchema(fa.IDSchema[Blog]):\n    title: str\n\n\n@fa.include_view(app)\nclass BlogView(fa.AsyncAlchemyView):\n    prefix = \"/blogs\"\n    model = Blog\n    schema = BlogSchema\no```\nThis creates five endpoints:\n\n- `GET /blogs` \u2013 (TODO:  trailing slash??) list all items, with support for filtering and sorting  \n- `POST /blogs` \u2013 create a new item  \n- `GET /blogs/&lt;id&gt;` \u2013 retrieve a single item by ID  \n- `PUT /blogs/&lt;id&gt;` \u2013 update an existing item  \n- `DELETE /blogs/&lt;id&gt;` \u2013 delete an item by ID\n\nAnd produced [this OpenaAPI specification](TODO).\n\n### That's Too Implicit for My Pythonic Senses\n\nWhere's the Pydantic model? What exactly is `IDBase`?\n\nWe get it \u2014 implicitness can be annoying. On the other hand, explicitness gets repetitive once you've seen the same patterns ten times. Code is all about choosing your trade-offs.\n\nLuckily, `fa` lets you choose your level of abstraction. Here\u2019s a more explicit example if you prefer seeing the details up front.\n```python\nimport fastapi_alchemy as fa\nfrom fastapi import FastAPI\nfrom sqlalchemy import Mapped, mapped_column\n\napp = FastAPI()\n\nclass World(fa.AlchemyView):\n    id: Mapped[int] = mapped_column(primary_key=True)\n    message: Mapped[str]\n\nclass WorldSchema(fa.BaseSchema):\n    id: int\n    message: str\n\n@fa.include_view(app)\nclass WorldView(fa.AlchemyView):\n    prefix = \"world\"\n    model = World\n    schema = WorldSchema\n</code></pre> <p>No hidden <code>id</code> column, no hidden Pydantic schema. Ahh, much better.</p> <p>Of course, many things are still abstracted away. But surely you don\u2019t want to know everything. You\u2019ve got stuff to do.</p>"},{"location":"#show-me-all-that-it-can-do","title":"Show Me All That It Can Do","text":"<p>Minimal examples look nice, but reality never turns out that way. Let's dive into the deep end where any serious project finds itself rather soon. Here is an example that includes relationships, nested models, custom routes, and class-level dependencies.</p> <pre><code>from fastapi_alchemy import fa\nfrom fastapi import FastAPI\nfrom sqlalchemy import Mapped, mapped_column\n\napp = FastAPI()\n\nclass Product(fa.SQLBase, fa.TimestampMixin):\n    id: Mapped[UUID] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    addresses: relationship.. many-to-many\n    blog_posts: relationship.. 1 to many\n\nclass Order(fa.IDStampsBase):\n    population: Mapped[int]\n\nclass UserSchema(fa.BaseSchema):\n    id: UUID\n    blog_posts: list['CitySchema']\n\nclass CitySchema(TimestampsSchemaMixin):\n    read_only_fields: ClassVar = [\"population\"]\n    population: int\n\n@fa.include_view(app)\nclass WorldView(view.AlchemyView):\n    prefix = \"world\"\n    model = World\n    schema = WorldSchema\n\n    @view.route(\"/ola\")\n    async def\n</code></pre> <p>We are going to unpack what happens here, so you know what you can and cannot do with <code>fa</code>. Here is a list of things that might interest you:</p> <ul> <li>[[fastapi-ding-docs/Custom endpoints]]</li> <li>Custom FastAPI dependencies on views</li> <li>REST views unrelated to SQLAlchemy or a database</li> <li>Other types of primary keys, i.e. UUID id</li> <li>Custom create and update schemas</li> <li>Disable default endpoints</li> <li>Nesting REST views</li> </ul> <p>This includes an explicit Pydantic schema and an explicit <code>id</code> column. Under the hood <code>fa</code> creates two more Pydantic schemas: A <code>creation_schema</code> that excludes read-only fields (like <code>id</code>). The <code>creation_schema</code> is used on the <code>POST</code> endpoint. It also create an <code>update_schema</code>, where everything is optional. This <code>update_schema</code> enables (partial) <code>PUT</code> requests.</p> <p>Tutorial</p>"},{"location":"Custom%20endpoints/","title":"Custom endpoints","text":"<p>You've got your CRUD endpoints, what more could you possibly want? Oh the boss wants to download an XML file generated from your Elasticsearch index, but with all the key-values reversed?</p> <pre><code>from fastapi_alchemy import AsyncAlchemyView, include_view\n\n@include_view(app)\nclass MyView(SQLAlchemy):\n\n    @view_route()\n    def disappointment(self):\n</code></pre>"},{"location":"Imports/","title":"Imports","text":"<p>FastAPI-Alchemy provides utilities for views, schema's (Pydantic models), models (SQLAlchemy models) and others.  How do we want to import those? It can be nice to have short name import like <code>import pandas as pd</code> but at the same time that is a bit.. dirty? <code>import fastapi_alchemy as ding</code>?  Or,  <code>from fastapi_alchemy import views, schemas, sqlbase</code> Or, <code>from fastapi_alchemy import AsyncAlchemyView, IDBase, TimestampMixin, etc, etc.</code></p>"},{"location":"existing/","title":"Using FastAPI-Alchemy in an Existing Project","text":"<p><code>fa</code> can be used in any existing FastAPI project that also uses SQLAlchemy. Other ORMs are not supported.</p>"},{"location":"existing/#let-fa-use-your-sqlalchemy-session","title":"Let <code>fa</code> Use Your SQLAlchemy Session","text":"<p>If you already have code that creates SQLAlchemy <code>AsyncSession</code> objects, you can tell <code>fa</code> to use it.</p> <pre><code>from typing import AsyncIterator\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastapi_alchemy import settings\n\nasync def my_get_db() -&gt; AsyncIterator[AsyncSession]:\n    ...\n    yield MyAsyncSession()\n\nsettings.session_generator = my_get_db()\n</code></pre> <p>The other way around is of course also possible. So if you have need for a database session outside of <code>fa</code>, import the session generator like this: <pre><code>from fastapi_alchemy import get_session\n\nwith get_session() as session:\n    session.execute(...)\n</code></pre></p>"},{"location":"existing/#let-fa-use-your-declarativebase-class","title":"Let <code>fa</code> Use Your DeclarativeBase Class","text":"<p>Wait, does <code>fa</code> even need any specific base class??</p>"},{"location":"todo/","title":"Where I am at right now","text":"<p>I want to get this out of the door ASAP. Please cut corners as much as you can. We want it LIVE LIVE LIVE.</p> <p>MAIN GOAL: Get the more complicated example project working. Secondary goal: Get the docs up to a minimal state to get anyone started.</p> <p>Which functionality can I skip?</p> <p>What is go live?</p>"},{"location":"todo/#1-it-is-on-github","title":"1. It is on GitHub","text":"<p>If it is public on GitHub it is open source\u2122 Doesn't have to be functional yet, so we can do this today!</p>"},{"location":"todo/#2-package-on-pypi","title":"2. Package on PYPI","text":"<p>Now it will for real. Minimal requirements for this: * Tests have enough coverage *  * Naming is sort-of stable * Minimal set of docs <p>Start with version 0.5</p>"},{"location":"todo/#future-to-dos-after-go-live","title":"Future to-dos (after go-live)","text":"<ul> <li>Update the docs</li> <li>Do multi python versions tests. From 3.10 upwards.</li> <li>Go over naming - Did I get the naming of things spot on?</li> <li>make_session? Maybe should be Session?</li> <li>Update the docs</li> <li>Start working on API docs</li> <li>Make clear getting started / tutorial</li> <li>Make nested views work nicely (concate route prefixes)</li> <li>Auto-create pydantic model from sqlalchemy model</li> <li>Improve query modifiers</li> <li>Maybe not use filter[field]= but just field= style?</li> <li>Add metadata to index response</li> <li>total_count</li> <li>filter options</li> <li>page count?</li> <li>Wrap all responses in {\"data\": {}} ?</li> <li>Create a nice tests suite that tests the example projects</li> </ul>"},{"location":"tutorial/","title":"Getting Started with FastAPI-Alchemy","text":""},{"location":"tutorial/#installation","title":"Installation","text":"<p>Start with creating a virtual environment.</p> <p>Then install <code>fastapi-ding</code> using <code>pip</code>.</p> <p><pre><code>$ pip install fastapi-ding\n</code></pre> Although Ding aims to minimize dependencies, it is built on top of FastAPI and SQLAlchemy so it necessarily comes with quite a list of installed packages.</p>"},{"location":"tutorial/#setting-up-new-fastapi-alchemy-project","title":"Setting Up New FastAPI-Alchemy Project","text":"<p>If you are already working on a FastAPI project and want to know how you can include Ding see Using Ding in an Existing Project.</p> <p>The simplest possible FastAPI-Alchemy project could look like this: <pre><code>from fastapi_alchemy import DingBase, AsyncAlchemyView\nfrom sqlalchemy import Mapped\n\nclass World(DingBase):\n    message: Mapped[str]\n\nclass WorldView(AsyncAlchemyView):\n    prefix = \"world\"\n    model = World\n</code></pre></p>"}]}